- content_for :head do
  %title Mongoid: 持久化|Persistence

%h1 持久化|Persistence

%p
  Mongoid 像其他 Ruby ORM/ODM 框架如 <a href="http://rubyonrails.org/">Active Record</a> 或 <a href="https://datamapper.org">Data Mapper</a> 一样，支持所有常见的 <tt>CRUD</tt> 操作。Mongoid 与众不同之处在于只对有修改的属性进行原子性地更新，而不是像其他框架那样把整个文档重新写入数据库一遍。
  |Mongoid supports all expected <tt>CRUD</tt> operations for those familiar
  with other Ruby mappers like
  <a href="http://rubyonrails.org/">Active Record</a> or
  <a href="https://datamapper.org">Data Mapper</a>.
  What distinguishes Mongoid from other mappers for MongoDB is that the
  general persistence operations perform atomic
  updates on only the fields that have changed instead of writing the entire
  document to the database each time.

%p
  本节将提供一些例子展示调用 Mongoid 语句时对数据库的实际操作。
  |The persistence sections will provide examples on what database operation
  is performed when executing the documented command.

.page-nav
  .container
    %ul.nav.nav-pills
      %li= link_to "标准持久化|Standard", "#standard"
      %li= link_to "原子性持久化|Atomic", "#atomic"
      %li= link_to "自定义持久化|Custom", "#custom"

%section#standard
  %h2 标准持久化|Standard

  %p
    Mongoid 标准的持久化方法和其他框架在形式上非常相近。下表中左边是调用的 Mongoid 的方法，右边是 Moped 驱动的实际操作。
    |Mongoid's standard persistence methods come in the form of common methods
    you would find in other mapping frameworks. The following table is a cheat
    sheet with the method in Mongoid on the right, and the Moped driver operation
    on the left.

  .well
    %table
      %tr
        %td.samurai= image_tag "/images/samurai.png"
        %td.note
          除非新建文档，Mongoid 从不把整个文档向数据库写入一遍。Mongoid 会找到哪些属性被修改，然后原子性地只更新这些修改的属性。
          |Mongoid never persists the entire document at once unless it is new.
          It figures out what has changed, and only ever updates the changed
          items atomically.

  %table.table.table-bordered.table-striped
    %thead
      %tr
        %th 操作|Operation
        %th Mongoid
        %th Moped
    %tbody
      %tr
        %td.doc
          <code>Model.create</code>
          %p.doc
            %i 将一个文档插入数据库集合|Insert a document into the dataabase
        %td
          :coderay
            #!ruby
            Person.create(
              first_name: "Heinrich",
              last_name: "Heine"
            )

            Person.create(first_name: "Heinrich") do |doc|
              doc.last_name = "Heine"
            end
        %td
          :coderay
            #!ruby
            collections[:people].insert({
              first_name: "Heinrich",
              last_name: "Heine"
            })
      %tr
        %td
          <code>Model.create!</code>
          %p.doc
            %i
              将一个文档插入数据库集合，如果验证失败则报错。
              |Insert a document into the dataabase,
              raising an error if a validation error occurs.
        %td
          :coderay
            #!ruby
            Person.create!(
              first_name: "Heinrich",
              last_name: "Heine"
            )

            Person.create!(first_name: "Heinrich") do |doc|
              doc.last_name = "Heine"
            end
        %td
          :coderay
            #!ruby
            collections[:people].insert({
              first_name: "Heinrich",
              last_name: "Heine"
            })
      %tr
        %td
          <code>Model#save</code>
          %p.doc
            %i
              原子性地将修改的属性存入数据库，如果是新的文档则插入数据库。如需要可以绕过验证。
              |Saves the changed attributes to the database
              atomically, or insert the document if new. Can
              bypass validations if wanted.
        %td
          :coderay
            #!ruby
            person = Person.new(
              first_name: "Heinrich",
              last_name: "Heine"
            )
            person.save
            person.save(validate: false)

            person.first_name = "Christian Johan"
            person.save
        %td
          :coderay
            #!ruby
            collections[:people].insert({
              first_name: "Heinrich",
              last_name: "Heine"
            })

            collections[:people].find(...).
              update("$set" => { first_name: "Christian Johan" })
      %tr
        %td
          <code>Model#save!</code>
          %p.doc
            %i
              原子性地将修改的属性存入数据库，如果是新的文档则插入数据库。如果验证失败则报错。
              |Saves the changed attributes to the database
              atomically, or insert the document if new. Will
              raise an error of validations fail.
        %td
          :coderay
            #!ruby
            person = Person.new(
              first_name: "Heinrich",
              last_name: "Heine"
            )
            person.save!

            person.first_name = "Christian Johan"
            person.save!
        %td
          :coderay
            #!ruby
            collections[:people].insert({
              first_name: "Heinrich",
              last_name: "Heine"
            })

            collections[:people].find(...).
              update("$set" => { first_name: "Christian Johan" })
      %tr
        %td
          <code>Model#update_attributes</code>
          %p.doc
            %i
              原子性地更新所提供的属性。
              |Update the provided attributes atomically.
        %td
          :coderay
            #!ruby
            person.update_attributes(
              first_name: "Jean",
              last_name: "Zorg"
            )
        %td
          :coderay
            #!ruby
            collections[:people].find(...).
              update("$set" => {
                first_name: "Jean",
                last_name: "Zorg"
              })
      %tr
        %td
          <code>Model#update_attributes!</code>
          %p.doc
            %i
              原子性地更新所提供的属性。如果验证失败则报错。
              |Update the attributes and raise an error if validation fails.
        %td
          :coderay
            #!ruby
            person.update_attributes!(
              first_name: "Jean",
              last_name: "Zorg"
            )
        %td
          :coderay
            #!ruby
            collections[:people].find(...).
              update("$set" => {
                first_name: "Jean",
                last_name: "Zorg"
              })
      %tr
        %td
          <code>Model#update_attribute</code>
          %p.doc
            %i
              更新单个属性，绕过所有验证。
              |Update a single attribute, bypassing validations.
        %td
          :coderay
            #!ruby
            person.update_attribute(:first_name, "Jean")
        %td
          :coderay
            #!ruby
            collections[:people].find(...).
              update("$set" => { first_name: "Jean" })
      %tr
        %td
          <code>Model#touch</code>
          %p.doc
            %i
              更新文档的 updated_at 时间戳，也可以同时提供一个额外的时间字段用于更新。如果特别设置，本操作将会同时 touch 本文档的所有 <code>belongs_to</code> 关系。本操作跳过所有验证和回调。
              |Update the document's updated_at timestamp, optionally
              with one extra provided time field. This will cascade the
              touch to all <code>belongs_to</code> relations of the
              document with the option set. This operation skips validations
              and callbacks.
        %td
          :coderay
            #!ruby
            person.touch
            person.touch(:audited_at)
        %td
          :coderay
            #!ruby
            collections[:people].find(...).
              update("$set" => { updated_at: Time.now })

            collections[:people].find(...).
              update({
                "$set" => {
                  updated_at: Time.now,
                  audited_at: Time.now
                }
              })
      %tr
        %td
          <code>Model#delete</code>
          %p.doc
            %i
              从数据库中删除文档，并不执行回调。
              |Deletes the document from the database without
              running callbacks.
        %td
          :coderay
            #!ruby
            person.delete
        %td
          :coderay
            #!ruby
            collections[:people].find(...).remove
      %tr
        %td
          <code>Model#destroy</code>
          %p.doc
            %i
              从数据库中删除文档，并执行回调。
              |Deletes the document from the database while running
              destroy callbacks.
        %td
          :coderay
            #!ruby
            person.destroy
        %td
          :coderay
            #!ruby
            collections[:people].find(...).remove
      %tr
        %td
          <code>Model.delete_all</code>
          %p.doc
            %i
              从数据库中删除所有符合条件的文档，并不执行回调。
              |Deletes all documents from the database that match the
              provided attributes. Does not run any callbacks.
        %td
          :coderay
            #!ruby
            Person.delete_all

            Person.delete_all(first_name: "Heinrich")
        %td
          :coderay
            #!ruby
            collections[:people].find.remove_all

            collections[:people].find(first_name: "Heinrich").
              remove_all
      %tr
        %td
          <code>Model.destroy_all</code>
          %p.doc
            %i
              从数据库中删除所有符合条件的文档，并执行每个文档的回调。
              |Deletes all documents from the database that match the
              provided attributes. Runs each document's destroy
              callbacks
        %td
          :coderay
            #!ruby
            Person.destroy_all

            Person.destroy_all(first_name: "Heinrich")
        %td
          :coderay
            #!ruby
            collections[:people].find.remove_all

            collections[:people].find(first_name: "Heinrich").
              remove_all

%section#atomic
  %h2 原子性持久化|Atomic Persistence

  %p
    尽管 Mongoid 在幕后执行的都是原子性的操作，但有些情况下你可能想显式地执行这些操作，以防触及其他属性。Mongoid 也支持所有的这些原子性操作。
    |Although Mongoid performs atomic operations under the covers by default,
    there may be cases where you want to do this explicitly without
    persisting other fields. Mongoid provides support for all of
    these operations as well.

    .well
      %table
        %tr
          %td.samurai= image_tag "/images/samurai.png"
          %td.note
            在执行这些原子性操作时，不会执行任何回调或者任何验证。
            |When executing atomic operations via these methods, no callbacks
            will ever get run, nor will any validations.

    %table.table.table-bordered.table-striped
      %thead
        %tr
          %th 操作|Operation
          %th Mongoid
          %th Moped
      %tbody
        %tr
          %td.doc
            <code>Model#add_to_set</code><br/>
            %p.doc
              %i 在某字段上执行原子性的 $addToSet 操作。|Performs an atomic $addToSet on the field.
          %td
            :coderay
              #!ruby
              person.add_to_set(:aliases, "Bond")
          %td
            :coderay
              #!ruby
              collections[:people].find(...).
                update("$addToSet" => { aliases: "Bond" })
        %tr
          %td
            <code>Model#bit</code><br/>
            %p.doc
              %i 在某字段上执行原子性的 $bit 操作。|Performs an atomic $bit on the field.
          %td
            :coderay
              #!ruby
              person.bit(:age, { and: 10, or: 12 })
          %td
            :coderay
              #!ruby
              collections[:people].find(...).
                update("$bit" => { age: { and: 10, or: 12 }})
        %tr
          %td
            <code>Model#inc</code><br/>
            %p.doc
              %i 在某字段上执行原子性的 $inc 操作。|Performs an atomic $inc on the field.
          %td
            :coderay
              #!ruby
              person.inc(:age, 1)
          %td
            :coderay
              #!ruby
              collections[:people].find(...).
                update("$inc" => { age: 1 })
        %tr
          %td
            <code>Model#pop</code><br/>
            %p.doc
              %i 在某字段上执行原子性的 $pop 操作。|Performs an atomic $pop on the field.
          %td
            :coderay
              #!ruby
              person.pop(:aliases, 1)
          %td
            :coderay
              #!ruby
              collections[:people].find(...).
                update("$pop" => { aliases: 1 })
        %tr
          %td
            <code>Model#pull</code><br/>
            %p.doc
              %i 在某字段上执行原子性的 $pull 操作。|Performs an atomic $pull on the field.
          %td
            :coderay
              #!ruby
              person.pull(:aliases, "Bond")
          %td
            :coderay
              #!ruby
              collections[:people].find(...).
                update("$pull" => { aliases: "Bond" })
        %tr
          %td
            <code>Model#pull_all</code><br/>
            %p.doc
              %i 在某字段上执行原子性的 $pullAll 操作。|Performs an atomic $pullAll on the field.
          %td
            :coderay
              #!ruby
              person.pull_all(:aliases, [ "Bond", "James" ])
          %td
            :coderay
              #!ruby
              collections[:people].find(...).
                update("$pullAll" => { aliases: [ "Bond", "James" ]})
        %tr
          %td
            <code>Model#push</code><br/>
            %p.doc
              %i 在某字段上执行原子性的 $push 操作。|Performs an atomic $push on the field.
          %td
            :coderay
              #!ruby
              person.push(:aliases, "007")
          %td
            :coderay
              #!ruby
              collections[:people].find(...).
                update("$push" => { aliases: "007" })
        %tr
          %td
            <code>Model#push_all</code><br/>
            %p.doc
              %i 在某字段上执行原子性的 $pushAll 操作。|Performs an atomic $pushAll on the field.
          %td
            :coderay
              #!ruby
              person.push_all(:aliases, [ "007", "008" ])
          %td
            :coderay
              #!ruby
              collections[:people].find(...).
                update("$pushAll" => { aliases: [ "007", "008" ]})
        %tr
          %td
            <code>Model#rename</code><br/>
            %p.doc
              %i 在某字段上执行原子性的 $rename 操作。|Performs an atomic $rename on the field.
          %td
            :coderay
              #!ruby
              person.rename(:bday, :dob)
          %td
            :coderay
              #!ruby
              collections[:people].find(...).
                update("$rename" => { "bday" => "dob" })
        %tr
          %td
            <code>Model#set</code><br/>
            %p.doc
              %i 在某字段上执行原子性的 $set 操作。|Performs an atomic $set on the field.
          %td
            :coderay
              #!ruby
              person.set(:name, "Tyler Durden")
          %td
            :coderay
              #!ruby
              collections[:people].find(...).
                update("$set" => { name: "Tyler Durden" })
        %tr
          %td
            <code>Model#unset</code><br/>
            %p.doc
              %i 在某字段上执行原子性的 $unset 操作。|Performs an atomic $unset on the field.
          %td
            :coderay
              #!ruby
              person.unset(:name)
          %td
            :coderay
              #!ruby
              collections[:people].find(...).
                update("$unset" => { name: 1 })

%section#custom
  %h2 自定义持久化|Custom

  %p
    有些情况下你可能希望在默认以外的其他地方储存文档，或者指定默认值以外的其他持久化选项。Mongoid 既支持运行时自定义这些选项，也支持按 Model 自定义这些选项。
    |There may be cases where you want to persist documents to different
    sources from their defaults, or with different options from the default.
    Mongoid provides run-time support for this as well as support on a per-model
    basis.

  %h3
    按 Model 自定义持久化选项|Model Level Persistence Options

  %p
    你可以指定将某个 Model 下的所有文档储存于一个特定的集合、数据库或会话。下面的例子将 Band 类的文档储存于“Secondary”会话的“music”数据库的“artists”集合内。
    |On a per-model basis, you can tell it to store in a custom collection name,
    a different database, or a different session. The following example would
    store the Band class by default into a collection named "artists" in the
    database named "music", with the session "secondary".

    .well
      %table
        %tr
          %td.samurai= image_tag "/images/samurai.png"
          %td.note
            注意 <code>session</code> 的值必须在 <code>mongoid.yml</code> 中已经配置。
            |Note that the value supplied to the <code>session</code> option must be
            configured under <code>sessions</code> in your mongoid.yml.

  :coderay
    #!ruby
    class Band
      include Mongoid::Document
      store_in collection: "artists", database: "music", session: "secondary"

  %p
    如果没有指定 <code>store_in</code> 宏，Mongoid 会把 Band 类的文档存在默认会话的默认数据库的名为“bands”的集合中。
    |If no `store_in` macro would have been provided, Mongoid would store the model
    in a collection named "bands" in the default database in the default session.

  %h3
    运行时持久化选项|Runtime Persistence Options

  %p
    只需给操作添加前缀 <code>#with</code>，即可在运行时决定在哪里执行 <tt>CRUD</tt> 操作。
    |You can change at runtime where to store, query, update, or remove documents
    by prefixing any operation with <code>#with</code>.

  :coderay
    #!ruby
    Band.with(database: "music-non-stop").create
    Band.with(collection: "artists").delete_all
    band.with(session: :tertiary).save!

  %p
    <code>#with</code> 也可以用来在运行时临时改变安全模式选项。
    |<code>#with</code>is also used for changing safe mode options temporarily
    at runtime.

  :coderay
    #!ruby
    Band.with(safe: true).create
    Band.with(safe: { w: 3 }).create!

  %p
    下列值可以传给 <code>:safe</code>：
    |The values that can be passed with <code>:safe</code> are:

  %ul
    %li <code>true</code>: 以安全模式持久化，无附加选项。|Persist in safe mode, no extra options.
    %li <code>false</code>: 不要以安全模式持久化。|Don't persist in safe mode.
    %li <code>fsync: true|false</code>: 是否执行 fsync。|Whether to perform an fsync.
    %li <code>w: n</code>: 返回前写入的节点的个数。|The number of nodes to write to before returning.
    %li <code>wtimeout: n</code>: 写入多个节点的超时值。|The timeout value for writing to multiple nodes.

  %h3 对会话和集合的操作|Session and Collection Access

  %p
    如果你想深入驱动的层面执行一些操作，你可以从 Model 或者文档实例获取 Moped 会话或集合。
    |If you want to drop down to the driver level to perform operations, you
    can grab the Moped session or collection from the model or document instance.

  :coderay
    #!ruby
    Band.mongo_session
    band.mongo_session
    Band.collection
    band.collection

  %p
    你也可以从这里使用 Moped 的 <code>#with</code> 来设置运行时持久化选项。这些将会在 Moped 的文档中作深入介绍。
    |From here you also have the same runtime persistence options using Moped's
    <code>#with</code>. The Moped documentation will go into more detail
    about this.

  :coderay
    #!ruby
    Band.mongo_session.with(safe: false, database: "musik") do |session|
      session[:artists].find(...)
    end

  %h3 有限集合（Capped Collections）|Capped Collections

  %p
    Mongoid 并未提供创建有限集合的机制，你需要自己通过 Moped 或 mongo 控制台手动创建。
    |Mongoid does not provide a mechanism for creating capped collections on
    the fly - you will need to create these yourself one time up front either
    with Moped or via the Mongo console.

  %p
    使用 Moped 创建有限集合：|To create a capped collection with Moped:

  :coderay
    #!ruby
    session.command(create: "name", capped: true, size: 10000000, max: 1000)

  %p
    使用 mongo 控制台创建有限集合：|To create a capped collection from the Mongo console:

  :coderay
    #!javascript
    db.createCollection("name", { capped: true, size: 10000000, max: 1000 });
