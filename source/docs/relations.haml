- content_for :head do
  %title Mongoid: Relations

%h1 Relations

%p
  Relations are associations between one model and another in the domain
  and in the database. Embedded relations describe documents who are
  stored inside other documents in the database. Referenced relations
  describe documents that reference documents in another collection by
  storing foreign key data (usually an id) about the other document
  in itself.

%p
  All relation objects in Mongoid are proxies to the actual document or
  documents themselves, which provide extra functionality for accessing,
  replacing, appending and persisting.

.page-nav
  %ul.nav.nav-pills
    %li= link_to "Common Behaviour", "#common"
    %li= link_to "Metadata", "#metadata"
    %li= link_to "Embedded 1-1", "#embeds_one"
    %li= link_to "Embedded 1-n", "#embeds_many"
    %li= link_to "Referenced 1-1", "#has_one"
    %li= link_to "Referenced 1-n", "#has_many"
    %li= link_to "Referenced n-n", "#has_and_belongs_to_many"

%section#common
  %h2 Common Behaviour

  %h3 Attributes

  %p
    All relations contain a <code>target</code>, which is the proxied document
    or documents, a <code>base</code> which is the document the relation hangs
    off, and <code>metadata</code> which provides information about the relation.

  :coderay
    #!ruby

    class Person
      include Mongoid::Document
      embeds_many :addresses
    end

    person.addresses = [ address ]
    person.addresses.target # returns [ address ]
    person.addresses.base # returns person
    person.addresses.metadata # returns the metadata

  %h3 Extensions

  %p
    All relations can have extensions, which provides a way to add
    application specific functionality to the relation. They are defined by
    providing a block to the relation definition.

  :coderay
    #!ruby

    class Person
      include Mongoid::Document
      embeds_many :addresses do
        def find_by_country(country)
          where(country: country).first
        end
        def chinese
          @target.select { |address| address.country == "China"}
        end
      end
    end

    person.addresses.find_by_country("Mongolia") # returns address
    person.addresses.chinese # returns [ address ]

  %h3 Custom Relation Names

  %p
    You can name your relations whatever you like, but if the class cannot be
    inferred by Mongoid from the name, and neither can the opposite side you'll
    want to provide the macro with some additional options to tell Mongoid
    how to hook them up.

  :coderay
    #!ruby

    class Lush
      include Mongoid::Document
      embeds_one :whiskey, class_name: "Drink", inverse_of: :alcoholic
    end

    class Drink
      include Mongoid::Document
      embedded_in :alcoholic, class_name: "Lush", inverse_of: :whiskey
    end

  %h3 Validations

  %p
    It is important to note that by default, Mongoid will validate the
    children of any relation that are loaded into memory via a
    <code>validates_associated</code>. The relations that this applies to are:

    %ul
      %li <code>embeds_many</code>
      %li <code>embeds_one</code>
      %li <code>has_many</code>
      %li <code>has_one</code>
      %li <code>has_and_belongs_to_many</code>

  %p
    If you do not want this behaviour, you may turn it off when defining
    the relation.

  :coderay
    #!ruby
    class Person
      include Mongoid::Document

      embeds_many :addresses, validate: false
      has_many :posts, validate: false
    end

  %h3 Polymorphism

  %p
    When a child embedded document can belong to more than one type of parent
    document, you can tell Mongoid to support this by adding the <code>as</code>
    option to the definition on the parents, and the <code>polymorphic</code>
    option on the child. On the child object, and additional field will be
    stored that indicates the type of the parent.

  .well
    %table
      %tr
        %td.samurai= image_tag "/images/samurai.png"
        %td.note
          %p
            Polymorhic behaviour is allowed on all relations with the
            exception of <code>has_and_belongs_to_many</code>.

  :coderay
    #!ruby

    class Band
      include Mongoid::Document
      embeds_many :photos, as: :photographic
      has_one :address, as: :addressable
    end

    class Photo
      include Mongoid::Document
      embedded_in :photographic, polymorphic: true
    end

    class Address
      include Mongoid::Document
      belongs_to :addressable, polymorphic: true
    end

  %h3 Cascading Callbacks

  %p
    If you want the embedded document callbacks to fire when calling a persistence
    operation on it's parent, you will need to provide the cascade callbacks
    option to the relation.

  .well
    %table
      %tr
        %td.samurai= image_tag "/images/samurai.png"
        %td.note
          %p
            Cascading callbacks is only available on <code>embeds_one</code>
            and <code>embeds_many</code> relations.

  :coderay
    #!ruby
    class Band
      include Mongoid::Document
      embeds_many :albums, cascade_callbacks: true
      embeds_one :label, cascade_callbacks: true
    end

    band.save # Fires all save callbacks on the band, albums, and label.

  %h3 Dependent Behaviour

  %p
    You can provided dependent options to referenced associations to
    instruct Mongoid how to handle situations where one side of the
    relation is deleted, or is attempted to be deleted. The options
    are as follows:

  %ul
    %li <code>:delete</code>: Delete the child document.
    %li <code>:destroy</code>: Destroy the child document.
    %li <code>:nullify</code>: Orphan the child document.
    %li <code>:restrict</code>: Raise an error if the child is not empty.

  .well
    %table
      %tr
        %td.samurai= image_tag "/images/samurai.png"
        %td.note
          %p Dependent options are only available on referenced relations.

  %p
    The default behaviour of each association when no dependent option
    is provided is to nullify.

  :coderay
    #!ruby
    class Band
      include Mongoid::Document
      has_many :albums, dependent: :delete
      belongs_to :label, dependent: :nullify
    end

    class Album
      include Mongoid::Document
      belongs_to :band
    end

    class Label
      include Mongoid::Document
      has_many :bands, dependent: :restrict
    end

    label = Label.first
    label.bands.push(Band.first)
    label.delete # Raises an error since bands is not empty.

    Band.first.delete # Will delete all associated albums.

  %h3 Recursive Embedding

  %p
    A document can recursively embed itself using
    <code>recursively_embeds_one</code> or <code>recursively_embeds_many</code>,
    which provides accessors for the parent and children via <code>parent_</code>
    and <code>child_</code> methods.

  .well
    %table
      %tr
        %td.samurai= image_tag "/images/samurai.png"
        %td.note
          %p Recursive options are only available on embedded relations.

  :coderay
    #!ruby

    class Tag
      include Mongoid::Document
      recursively_embeds_many
    end

    root = Tag.new(name: "programming")
    child_one = root.child_tags.build
    child_one = root.child_tags.build

    root.child_tags # [ child_one, child_two ]
    child_one.parent_tag # [ root ]
    child_two.parent_tag # [ root ]

    class Node
      include Mongoid::Document
      recursively_embeds_one
    end

    root = Node.new
    child = Node.new
    root.child_node = child

    root.child # child
    child.parent_node # root

%section#metadata
  %h2 Metadata

  %p
    All relations in Mongoid contain metadata that holds information
    about the relation in question, and is a valuable tool for third
    party developers to use to extend Mongoid.

  %p
    You can access the metadata of the relation in a few different ways.

  :coderay
    #!ruby
    # Get the metadata for a named relation from the class or document.
    Model.reflect_on_association(:relation_name)
    model.reflect_on_association(:relation_name)

    # Get the metadata that the current object has in its relation.
    model.metadata

    # Get the metadata with a specific relation itself on a specific
    # document.
    person.addresses.metadata

  %h3 The Metadata Object

  %p
    The metadata object itself contains more information than one might
    know what to do with, and is useful for developers of extensions
    to Mongoid.

  %table.table.table-bordered.table-striped
    %thead
      %tr
        %th Method
        %th Description
    %tr
      %td <code>Metadata#as</code>
      %td Returns the name of the parent to a polymorphic child.
    %tr
      %td <code>Metadata#as?</code>
      %td Returns whether or not an as option exists.
    %tr
      %td <code>Metadata#autobuilding?</code>
      %td Returns whether or not the relation is autobuilding.
    %tr
      %td <code>Metadata#autosaving?</code>
      %td Returns whether or not the relation is autosaving.
    %tr
      %td <code>Metadata#cascading_callbacks?</code>
      %td
        Returns whether the relation has callbacks cascaded down from
        the parent.
    %tr
      %td <code>Metadata#class_name</code>
      %td Returns the class name of the proxied document.
    %tr
      %td <code>Metadata#cyclic?</code>
      %td Returns whether the relation is a cyclic relation.
    %tr
      %td <code>Metadata#dependent</code>
      %td Returns the relation's dependent option.
    %tr
      %td <code>Metadata#dependent?</code>
      %td Returns whether the relation is a dependent relation.
    %tr
      %td <code>Metadata#destructive?</code>
      %td Returns true if the relation has a dependent delete or destroy.
    %tr
      %td <code>Metadata#embedded?</code>
      %td Returns whether the relation is embedded in another document.
    %tr
      %td <code>Metadata#forced_nil_inverse?</code>
      %td Returns whether the relation has a nil inverse defined.
    %tr
      %td <code>Metadata#foreign_key</code>
      %td Returns the name of the foreign key field.
    %tr
      %td <code>Metadata#foreign_key_check</code>
      %td Returns the name of the foreign key field dirty check method.
    %tr
      %td <code>Metadata#foreign_key_setter</code>
      %td Returns the name of the foreign key field setter.
    %tr
      %td <code>Metadata#indexed?</code>
      %td Returns whether the foreign key is auto indexed.
    %tr
      %td <code>Metadata#inverses</code>
      %td Returns the names of all inverse relation.
    %tr
      %td <code>Metadata#inverse</code>
      %td Returns the name of a single inverse relation.
    %tr
      %td <code>Metadata#inverse_class_name</code>
      %td Returns the class name of the relation on the inverse side.
    %tr
      %td <code>Metadata#inverse_foreign_key</code>
      %td Returns the name of the foreign key field on the inverse side.
    %tr
      %td <code>Metadata#inverse_klass</code>
      %td Returns the class of the relation on the inverse side.
    %tr
      %td <code>Metadata#inverse_metadata</code>
      %td Returns the metadata of the relation on the inverse side.
    %tr
      %td <code>Metadata#inverse_of</code>
      %td Returns the explicitly defined name of the inverse relation.
    %tr
      %td <code>Metadata#inverse_of?</code>
      %td Returns whether an <code>inverse_of</code> option is defined.
    %tr
      %td <code>Metadata#inverse_setter</code>
      %td Returns the name of the method used to set the inverse.
    %tr
      %td <code>Metadata#inverse_type</code>
      %td Returns the name for the polymorphic type field of the inverse.
    %tr
      %td <code>Metadata#inverse_type_setter</code>
      %td Returns the name for the polymorphic type field setter of the inverse.
    %tr
      %td <code>Metadata#key</code>
      %td
        Returns the name of the field in the attributes hash to use to get
        the relation.
    %tr
      %td <code>Metadata#klass</code>
      %td Returns the class of the proxied documents in the relation.
    %tr
      %td <code>Metadata#macro</code>
      %td Returns the relation's macro.
    %tr
      %td <code>Metadata#name</code>
      %td Returns the relation name.
    %tr
      %td <code>Metadata#options</code>
      %td Returns self, for API compatibility with Active Record.
    %tr
      %td <code>Metadata#order</code>
      %td Returns the custom sorting options on the relation.
    %tr
      %td <code>Metadata#order?</code>
      %td Returns whether custom sorting options are set.
    %tr
      %td <code>Metadata#polymorphic?</code>
      %td Returns whether the relation is polymorphic.
    %tr
      %td <code>Metadata#setter</code>
      %td Returns the name of the field to set the relation.
    %tr
      %td <code>Metadata#store_as</code>
      %td Returns the name of the attribute to store an embedded relation in.
    %tr
      %td <code>Metadata#type</code>
      %td Returns the name of the field to get the polymorphic type.
    %tr
      %td <code>Metadata#type_setter</code>
      %td Returns the name of the field to set the polymorphic type.
    %tr
      %td <code>Metadata#validate?</code>
      %td Returns whether the relation has an associated validation.
    %tr
      %td <code>Metadata#versioned?</code>
      %td Returns whether the relation is an embedded version.

%section#embeds_one
  %h2 Embedded 1-1

  %p
    One to one relationships where the children are embedded in the parent
    document are defined using Mongoid's <code>embeds_one</code> and
    <code>embedded_in</code> macros.

  %h3 Defining

  %p
    The parent document of the relation should use the <code>embeds_one</code>
    macro to indicate is has 1 embedded child, where the document that
    is embedded uses <code>embedded_in</code>.

  :coderay
    #!ruby

    class Band
      include Mongoid::Document
      embeds_one :label
    end

    class Label
      include Mongoid::Document
      field :name, type: String
      embedded_in :band
    end

  .well
    %table
      %tr
        %td.samurai= image_tag "/images/samurai.png"
        %td.note
          %p
            Definitions are required on both sides to the relation in order
            for it to work properly.

  %h3 Storage

  %p
    Documents that are embedded using the <code>embeds_one</code> macro are stored
    as a hash inside the parent in the parent's database collection.

  :coderay
    #!javascript

    {
      "_id" : ObjectId("4d3ed089fb60ab534684b7e9"),
      "label" : {
        "_id" : ObjectId("4d3ed089fb60ab534684b7e0"),
        "name" : "Mute",
      }
    }

  %h3 Operations

  %p
    Once the relation is defined, the following operations are available, and
    the following table shows any database operations that are performed if
    applicable. The previously defined models will be used for example code.

  %table.table.table-bordered.table-striped
    %thead
      %tr
        %th Operation
        %th Mongoid
        %th Moped
    %tbody
      %tr
        %td.doc
          <code>Model\#{name}</code>
          %p.doc
            %i Get the embedded document.
        %td
          :coderay
            #!ruby
            band.label
        %td
      %tr
        %td.doc
          <code>Model\#{name}=</code>
          %p.doc
            %i
              Set the embedded document. If the parent document is persisted,
              then the child will be atomically saved immediately. If setting
              to <code>nil</code> then the child will be deleted.
        %td
          :coderay
            #!ruby
            band.label = Label.new(name: "Mute")

            band.label = nil
        %td
          :coderay
            #!ruby
            collections[:bands].find(...).
              update(
                "$set" => { label: { name: "Mute" }}
              )

            collections[:bands].find(...).
              update("$unset" => { label: true })

      %tr
        %td.doc
          <code>Model\#{parent_name}</code>
          %p.doc
            %i
              Get the parent document from the child.
        %td
          :coderay
            #!ruby
            label.band
        %td
      %tr
        %td.doc
          <code>Model\#{parent_name}=</code>
          %p.doc
            %i
              Set the parent document from the child.
        %td
          :coderay
            #!ruby
            label.band = Band.new
        %td
      %tr
        %td.doc
          <code>Model#build_{name}</code>
          %p.doc
            %i
              Build a new document on the relation.
        %td
          :coderay
            #!ruby
            band.build_label(name: "Mute")

            label.build_band(name: "Depeche Mode")
        %td
      %tr
        %td.doc
          <code>Model#create_{name}</code>
          %p.doc
            %i
              Create a new document from either side of the relation.
              This persists the child immediately if executing from the parent,
              and persists the entire tree if executed from the child.
        %td
          :coderay
            #!ruby
            band.create_label(name: "Mute")

            label.create_band({
              name: "Depeche Mode"
            })
        %td
          :coderay
            #!ruby
            collections[:bands].find(...).
              update(
                "$set" => { label: { name: "Mute" }}
              )

            collections[:bands].
              insert({
                name: "Depeche Mode",
                label: { name: "Mute" }
              })
      %tr
        %td.doc
          <code>Model#create_{name}</code>
          %p.doc
            %i
              Create a new document from either side of the relation.
              This persists the child immediately if executing from the parent,
              and persists the entire tree if executed from the child.
        %td
          :coderay
            #!ruby
            band.create_label(name: "Mute")

            label.create_band({
              name: "Depeche Mode"
            })
        %td
          :coderay
            #!ruby
            collections[:bands].find(...).
              update(
                "$set" => { label: { name: "Mute" }}
              )

            collections[:bands].
              insert({
                name: "Depeche Mode",
                label: { name: "Mute" }
              })

%section#embeds_many
  %h2 Embedded 1-n

  %p
    One to many relationships where the children are embedded in the parent
    document are defined using Mongoid's <code>embeds_many</code> and
    <code>embedded_in</code> macros.

  %h3 Defining

  %p
    The parent document of the relation should use the <code>embeds_many</code>
    macro to indicate it has <i>n</i> number of embedded children, where
    the document that is embedded uses <code>embedded_in</code>.

  :coderay
    #!ruby

    class Band
      include Mongoid::Document
      embeds_many :albums
    end

    class Album
      include Mongoid::Document
      field :name, type: String
      embedded_in :band
    end

  .well
    %table
      %tr
        %td.samurai= image_tag "/images/samurai.png"
        %td.note
          %p
            Definitions are required on both sides to the relation in order
            for it to work properly.

  %h3 Storage

  %p
    Documents that are embedded using the <code>embeds_many</code> macro are stored
    as an array of hashes inside the parent in the parent's database
    collection.

  :coderay
    #!javascript

    {
      "_id" : ObjectId("4d3ed089fb60ab534684b7e9"),
      "albums" : [
        {
          "_id" : ObjectId("4d3ed089fb60ab534684b7e0"),
          "name" : "Violator",
        }
      ]
    }

  %h3 Operations

  %p
    Once the relation is defined, the following operations are available, and
    the following table shows any database operations that are performed if
    applicable. The previously defined models will be used for example code.

  %table.table.table-bordered.table-striped
    %thead
      %tr
        %th Operation
        %th Mongoid
        %th Moped
    %tbody
      %tr
        %td.doc
          <code>Model\#{name}</code>
          %p.doc
            %i Get the embedded documents.
        %td
          :coderay
            #!ruby
            band.albums
        %td
      %tr
        %td.doc
          <code>Model\#{name}=</code>
          %p.doc
            %i
              Set the embedded documents. If the parent document is persisted,
              then the child will be atomically saved immediately. If setting
              to <code>nil</code> or <code>[]</code> then the children will be
              deleted.
        %td
          :coderay
            #!ruby
            band.albums = [ Album.new(name: "Violator") ]

            band.albums = nil
            band.albums = []
        %td
          :coderay
            #!ruby
            collections[:bands].find(...).
              update(
                "$set" => { albums: [{ name: "Violator" }]}
              )

            collections[:bands].find(...).
              update("$unset" => { albums: true })

      %tr
        %td.doc
          <code>Model\#{parent_name}</code>
          %p.doc
            %i
              Get the parent document from any child.
        %td
          :coderay
            #!ruby
            album.band
        %td
      %tr
        %td.doc
          <code>Model\#{parent_name}=</code>
          %p.doc
            %i
              Set the parent document from a child.
        %td
          :coderay
            #!ruby
            album.band = Band.new
        %td
      %tr
        %td.doc
          <code>Model\#{name}.<<</code><br/>
          <code>Model\#{name}.push</code>
          %p.doc
            %i
              Push a new document onto the relation. If the parent is
              persisted, then the child documents will be automatically
              saved.
        %td
          :coderay
            #!ruby
            band.albums << Album.new(name: "Violator")
            band.albums.push(Album.new(name: "Violator"))
        %td
          :coderay
            #!ruby
            collections[:bands].find(...).
              update(
                "$push" => { albums: { name: "Violator" }}
              )
      %tr
        %td.doc
          <code>Model\#{name}.concat</code>
          %p.doc
            %i
              Push multiplpe document onto the relation. If the parent is
              persisted, then the child documents will be automatically
              saved.
        %td
          :coderay
            #!ruby
            band.albums.concat(
              Album.new(name: "Violator"),
              Album.new(name: "101")
            )
        %td
          :coderay
            #!ruby
            collections[:bands].find(...).
              update(
                "$pushAll" => {
                  albums: [{ name: "Violator" }, { name: "101" }]
                }
              )
      %tr
        %td.doc
          <code>Model\#{name}.build</code><br/>
          <code>Model\#{name}.new</code>
          %p.doc
            %i
              Build a new document in the relation with the provided
              attributes. Does not save the new document.
        %td
          :coderay
            #!ruby
            band.albums.build(name: "Violator")
            band.albums.new(name: "Violator")
        %td
      %tr
        %td.doc
          <code>Model\#{name}.create</code><br/>
          <code>Model\#{name}.create!</code>
          %p.doc
            %i
              Create a new document in the relation with the provided
              attributes and saves. With the bang version an error will
              be raised if validation fails.
        %td
          :coderay
            #!ruby
            band.albums.create(name: "Violator")
            band.albums.create!(name: "Violator")
        %td
          :coderay
            #!ruby
            collections[:bands].find(...).
              update(
                "$push" => { albums: { name: "Violator" }}
              )
      %tr
        %td.doc
          <code>Model\#{name}.clear</code><br/>
          <code>Model\#{name}.delete_all</code>
          %p.doc
            %i
              Deletes all documents from the relation, without
              running any callbacks.
        %td
          :coderay
            #!ruby
            band.albums.clear
            band.albums.delete_all
            band.albums.delete_all(name: "Violator")
            band.albums.
              where(name: "Violator").delete_all
        %td
          :coderay
            #!ruby
            collections[:bands].find(...).
              update(
                "$pullAll" => { albums: [{ name: "Violator" }]}
              )
      %tr
        %td.doc
          <code>Model\#{name}.destroy_all</code>
          %p.doc
            %i
              Deletes all documents from the relation, while
              running the destroy callbacks.
        %td
          :coderay
            #!ruby
            band.albums.destroy_all
            band.albums.destroy_all(name: "Violator")
            band.albums.
              where(name: "Violator").destroy_all
        %td
          :coderay
            #!ruby
            collections[:bands].find(...).
              update(
                "$pullAll" => { albums: [{ name: "Violator" }]}
              )
      %tr
        %td.doc
          <code>Model\#{name}.delete</code>
          %p.doc
            %i
              Deletes the matching document from the relation.
        %td
          :coderay
            #!ruby
            band.albums.delete(album)
        %td
          :coderay
            #!ruby
            collections[:bands].find(...).
              update(
                "$pull" => { albums: { name: "Violator" }}
              )
      %tr
        %td.doc
          <code>Model\#{name}.pop</code>
          %p.doc
            %i
              Deletes the provided number of documents, defaulting to 1.
        %td
          :coderay
            #!ruby
            band.albums.pop
            band.albums.pop(1)
        %td
          :coderay
            #!ruby
            collections[:bands].find(...).
              update(
                "$pullAll" => { albums: [{ name: "Violator" }]}
              )
      %tr
        %td.doc
          <code>Model\#{name}.find</code>
          %p.doc
            %i
              Return documents in the relation with matching ids. Will
              raise an error if all the ids are not found by default.
        %td
          :coderay
            #!ruby
            band.albums.find(id)
            band.albums.find(id_one, id_two)
        %td
      %tr
        %td.doc
          <code>Model\#{name}.find_or_create_by</code>
          %p.doc
            %i
              Search for the document in the relation, and if not found
              create a newly persisted one.
        %td
          :coderay
            #!ruby
            band.albums.
              find_or_create_by(name: "Violator")
        %td
          :coderay
            #!ruby
            collections[:bands].find(...).
              update(
                "$push" => { albums: { name: "Violator" }}
              )
      %tr
        %td.doc
          <code>Model\#{name}.find_or_initialize_by</code>
          %p.doc
            %i
              Search for the document in the relation, and if not found
              add a new one.
        %td
          :coderay
            #!ruby
            band.albums.
              find_or_initialize_by(name: "Violator")
        %td
      %tr
        %td.doc
          <code>Model\#{name}.where</code>
          %p.doc
            %i
              Find matching documents in the relation. This can be any
              criteria method, not just where.
        %td
          :coderay
            #!ruby
            band.albums.where(name: "Violator")
        %td
      %tr
        %td.doc
          <code>Model\#{name}.exists?</code>
          %p.doc
            %i
              Returns whether or not the relation has any documents.
        %td
          :coderay
            #!ruby
            band.albums.exists?
        %td

%h1 referenced one to one

%p
  One to one relationships where the children are referenced in the parent
  document are defined using Mongoid's <tt>has_one</tt> and
  <tt>belongs_to</tt> macros.

%h3 defining

%p
  The parent document of the relation should use the <tt>has_one</tt>
  macro to indicate is has 1 referenced child, where the document that
  is referenced in it uses <tt>belongs_to</tt>.

:coderay
  #!ruby

  class Person
    include Mongoid::Document
    has_one :game
  end

  class Game
    include Mongoid::Document
    field :name, type: String
    belongs_to :person
  end

%p
  Definitions are required on both sides to the relation in order for it to
  work properly.

%h3 storage

%p
  When defining a relation of this nature, each document is stored in it's
  respective collection, but the child document contains a "foreign key"
  reference to the parent.

:coderay
  #!ruby

  # The parent person document.
  { "_id" : ObjectId("4d3ed089fb60ab534684b7e9") }

  # The child post document.
  {
    "_id" : ObjectId("4d3ed089fb60ab534684b7f1"),
    "person_id" : ObjectId("4d3ed089fb60ab534684b7e9")
  }

%h3 accessors

%p
  Accessing the relations is handled through the methods created based on the
  names of the relations. The following example shows basic access on both
  sides of the relation.

:coderay
  #!ruby

  # Return the child game.
  person.game

  # Set the child game.
  person.game = [ Game.new ]

  # Return the parent person.
  game.person

  # Set the parent person.
  game.person = Person.new

%h3 building and creating

%p
  From the parent side, documents in the referenced child can be initialized or
  created using the specially defined methods.

:coderay
  #!ruby

  # Create a new child game given the provided attributes.
  person.build_game(name: "Tron")

  # Create a persisted child game.
  person.create_game(name: "Tron")

  # Replace the parent with a new one from the attributes.
  game.build_person(title: "Prince")

  # Replace the parent with a newly saved one from the attributes.
  game.create_person(title: "Prince")

%h3 removal

%p
  Documents in the referenced many can be removed by either calling delete
  on the child or setting it to nil.

:coderay
  #!ruby

  # Delete the child document
  person.game.delete
  person.game.destroy
  person.game = nil


%h1 referenced one to many

%p
  One to many relationships where the children are stored in a
  separate collection from the parent document are defined using
  Mongoid's <tt>has_many</tt> and <tt>belongs_to</tt> macros. This
  exhibits similar behaviour to Active Record.

%h3 defining

%p
  The parent document of the relation should use the <tt>has_many</tt>
  macro to indicate is has <i>n</i> number of referenced children, where
  the document that is referenced uses <tt>belongs_to</tt>.

:coderay
  #!ruby

  class Person
    include Mongoid::Document
    has_many :posts
  end

  class Post
    include Mongoid::Document
    field :title, type: String
    belongs_to :person
  end

%p
  Definitions are required on both sides to the relation in order for it to
  work properly.

%h3 storage

%p
  When defining a relation of this nature, each document is stored in it's
  respective collection, but the child document contains a "foreign key"
  reference to the parent.

:coderay
  #!ruby

  # The parent person document.
  { "_id" : ObjectId("4d3ed089fb60ab534684b7e9") }

  # The child post document.
  {
    "_id" : ObjectId("4d3ed089fb60ab534684b7f1"),
    "person_id" : ObjectId("4d3ed089fb60ab534684b7e9")
  }

%h3 accessors

%p
  Accessing the relations is handled through the methods created based on the
  names of the relations. The following example shows basic access on both
  sides of the relation.

:coderay
  #!ruby

  # Return the child posts.
  person.posts

  # Set the child posts.
  person.posts = [ Post.new ]

  # Return the parent person.
  post.person

  # Set the parent person.
  post.person = Person.new

%h3 building and creating

%p
  From the parent side, documents in the referenced child can be appended to using
  traditional array syntax or the special association proxy methods. On the
  child side the only option is to replace the existing with a newly built or
  created document.

:coderay
  #!ruby

  # Append one or many child posts, saving them if the person is persisted.
  person.posts << Post.new
  person.posts.push(Post.new)
  person.posts.concat([ post ])

  # Appends and returns a new child post from the attirbutes.
  person.posts.build(title: "Berlin never sleeps.")
  person.posts.new(title: "Berlin never sleeps.")

  # Appends, saves, and returns a new child post from the attirbutes.
  person.posts.create(title: "Berlin is far cooler than New York.")

  # Appends, saves, and returns a new child post from the attributes,
  # raising an error if validation fails.
  person.posts.create!(title: "Berlin is bad for the liver.")

  # Replace the parent with a new one from the attributes.
  post.build_person(title: "Prince")

  # Replace the parent with a newly saved one from the attributes.
  post.create_person(title: "Prince")

%h3 removal

%p
  Documents in the referenced many can be removed in several different manners,
  either through the relation, criteria, or accessors.

:coderay
  #!ruby

  # Delete all referenced documents
  person.posts.delete_all
  person.posts.clear
  person.posts = []

  # Delete all matching referenced documents.
  person.posts.delete_all(conditions: { title: "Berlin" })
  person.posts.where(title: "Berlin").delete_all

  # Destroy all referenced documents, running destroy callbacks.
  person.posts.destroy_all

  # Destroy all matching referenced documents, running callbacks.
  person.posts.destroy_all(conditions: { title: "Berlin" })
  person.posts.where(title: "Berlin").destroy_all

  # Delete the parent referenced document.
  post.person.delete

  # Destroy the parent referenced document.
  post.person.destroy

%h3 finding

%p
  Finding documents in the referenced children is handled through <tt>find</tt>
  or by using chained criteria on the relation.

:coderay
  #!ruby

  # Find a child by a single or multiple ids.
  person.posts.find(id)
  person.posts.find([ id_one, id_two ])

  # Find matching referenced children.
  person.posts.where(title: "Berlin")

  # Find or create a matching (saved) child.
  person.posts.find_or_create_by(title: "Berlin")

  # Find or initialize a matching (new) child.
  person.posts.find_or_initialize_by(title: "Berlin")

  # Do any children exist that are persisted?
  person.posts.exists?


%h1 referenced many to many

%p= image_tag "/images/referenced-n-n.png", class: "diagram"

%p
  Many to many relationships where the inverse documents are stored in a
  separate collection from the base document are defined using
  Mongoid's <tt>has_and_belongs_to_many</tt> macro. This
  exhibits similar behaviour to Active Record with the exception that
  no join collection is needed, the foreign key ids are stored as
  arrays on either side of the relation.

%h3 defining

%p
  Both sides of the relation use the same macro.

:coderay
  #!ruby

  class Person
    include Mongoid::Document
    field :title, type: String
    has_and_belongs_to_many :tags
  end

  class Tag
    include Mongoid::Document
    field :name, type: String
    has_and_belongs_to_many :people
  end

%p
  You can create a one sided many to many if you want to mimic a has_many
  that stores the keys as an array on the parent.

:coderay
  #!ruby

  class Movie
    include Mongoid::Document
    field :title, type: String
    has_and_belongs_to_many :ratings, inverse_of: nil
  end

  class Rating
    include Mongoid::Document
  end

%h3 storage

%p
  When defining a relation of this nature, each document is stored in it's
  respective collection, and each document contains a "foreign key"
  reference to the other in the form of an array.

:coderay
  #!ruby

  # The person document.
  {
    "_id" : ObjectId("4d3ed089fb60ab534684b7e9"),
    "tag_ids" : [ ObjectId("4d3ed089fb60ab534684b7f2") ]
  }

  # The tag document.
  {
    "_id" : ObjectId("4d3ed089fb60ab534684b7f2"),
    "person_ids" : [ ObjectId("4d3ed089fb60ab534684b7e9") ]
  }

%h3 accessors

%p
  Accessing the relations is handled through the methods created based on the
  names of the relations. The following example shows basic access on both
  sides of the relation.

:coderay
  #!ruby

  # Return the tags that belong to a person.
  person.tags

  # Set the tags from the person.
  person.tags = [ Tag.new ]

  # Return the people that belong to a tag.
  tag.people

  # Set the people from the tag.
  tag.people = [ Person.new ]

%h3 building and creating

%p
  From either side, documents in the referenced inverse can be appended to using
  traditional array syntax or the special association proxy methods.

:coderay
  #!ruby

  # Append one or many tags, saving them if the person is persisted.
  person.tags << Tag.new
  person.tags.push(Tag.new)
  person.tags.concat([ tag_one, tag_two ])

  # Appends and returns a new tag from the attributes.
  person.tags.build(name: "Buch")
  person.tags.new(name: "Buch")

  # Appends, saves, and returns a new tag from the attributes.
  person.tags.create(name: "Bar")

  # Appends, saves, and returns a new tag from the attributes,
  # raising an error if validation fails.
  person.tags.create!(name: "Bar")

  # Append one or many people, saving them if the tag is persisted.
  tag.people << Person.new
  tag.people.push(Person.new)
  tag.people.concat([ person_one, person_two ])

  # Appends and returns a new person from the attributes.
  tag.people.build(title: "Mr")
  tag.people.new(title: "Mr")

  # Appends, saves, and returns a new person from the attributes.
  tag.people.create(title: "Sire")

  # Appends, saves, and returns a new person from the attributes,
  # raising an error if validation fails.
  tag.people.create!(title: "Douchebag")

%h3 removal

%p
  Documents in the relation can be removed in several different manners,
  either through the relation, criteria, or accessors.

:coderay
  #!ruby

  # Delete all referenced documents
  person.tags.delete_all
  person.tags.clear
  person.tags = []

  # Delete all matching referenced documents.
  person.tags.delete_all(conditions: { name: "Ruby" })
  person.tags.where(name: "Rails").delete_all

  # Destroy all referenced documents, running destroy callbacks.
  person.tags.destroy_all

  # Destroy all matching referenced documents, running callbacks.
  person.tags.destroy_all(conditions: { name: "Ruby" })
  person.tags.where(name: "MongoDB").destroy_all

  # Delete all referenced documents
  tag.people.delete_all
  tag.people.clear
  tag.people = []

  # Delete all matching referenced documents.
  tag.people.delete_all(conditions: { title: "Sir" })
  tag.people.where(title: "Grand Poobah").delete_all

  # Destroy all referenced documents, running destroy callbacks.
  tag.people.destroy_all

  # Destroy all matching referenced documents, running callbacks.
  tag.people.destroy_all(conditions: { title: "Marshall" })
  tag.people.where(title: "Heiness").destroy_all

%h3 Saving

%p
  All changes to models, including the destruction of those marked for destruction,
  are saved and destroyed automatically and atomically when the parent model is saved.

